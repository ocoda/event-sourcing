## API Report File for "@ocoda/event-sourcing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DynamicModule } from '@nestjs/common';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { Logger } from '@nestjs/common';
import { ModuleMetadata } from '@nestjs/common';
import { Observable } from 'rxjs';
import { Subject } from 'rxjs';
import { Type } from '@nestjs/common';

// @public
export const Aggregate: (options?: AggregateMetadata) => ClassDecorator;

// @public (undocumented)
export const AGGREGATE_METADATA = "AGGREGATE_METADATA";

// @public
export interface AggregateMetadata {
    publishers?: IEventPublisher[];
    streamName?: string;
}

// @public (undocumented)
export abstract class AggregateRoot {
    // (undocumented)
    applyEvent<T extends IEvent = IEvent>(event: T, fromHistory?: boolean): void;
    // (undocumented)
    commit(): IEvent[];
    // (undocumented)
    loadFromHistory(eventCursor: AsyncGenerator<IEvent[]>): Promise<void>;
    set version(version: number);
    // (undocumented)
    get version(): number;
}

// @public (undocumented)
export const COMMAND_HANDLER_METADATA = "COMMAND_HANDLER_METADATA";

// @public (undocumented)
export const COMMAND_METADATA = "COMMAND_METADATA";

// @public (undocumented)
export class CommandBus<CommandBase extends ICommand = ICommand> extends ObservableBus<CommandBase> implements ICommandBus<CommandBase> {
    // (undocumented)
    bind<T extends CommandBase>(handler: ICommandHandler<T>, id: string): void;
    // (undocumented)
    execute<T extends CommandBase, R = any>(command: T): Promise<R>;
    // (undocumented)
    get publisher(): ICommandPublisher<CommandBase>;
    set publisher(_publisher: ICommandPublisher<CommandBase>);
    // (undocumented)
    register(handlers?: InstanceWrapper<ICommandHandler>[]): void;
    // (undocumented)
    protected registerHandler(handler: InstanceWrapper<ICommandHandler>): void;
}

// @public
export const CommandHandler: (command: ICommand) => ClassDecorator;

// @public (undocumented)
export interface CommandHandlerMetadata {
    // (undocumented)
    command: Type<ICommand>;
}

// @public (undocumented)
export class CommandHandlerNotFoundException extends Error {
    constructor(commandName: string);
}

// @public (undocumented)
export interface CommandMetadata {
    // (undocumented)
    id: string;
}

// @public (undocumented)
export const DEFAULT_BATCH_SIZE = 100;

// @public (undocumented)
export class DefaultCommandPubSub<CommandBase extends ICommand> implements ICommandPublisher<CommandBase> {
    constructor(subject$: Subject<CommandBase>);
    // (undocumented)
    publish<T extends CommandBase>(command: T): void;
}

// @public (undocumented)
export class DefaultEventSerializer<E extends IEvent = IEvent> implements IEventSerializer {
    // (undocumented)
    deserialize(payload: IEventPayload<E>): E;
    // (undocumented)
    static for<E extends IEvent = IEvent>(cls: Type<E>): DefaultEventSerializer<E>;
    // (undocumented)
    serialize(event: E): IEventPayload<E>;
}

// @public (undocumented)
export class DefaultQueryPubSub<QueryBase extends IQuery> implements IQueryPublisher<QueryBase> {
    constructor(subject$: Subject<QueryBase>);
    // (undocumented)
    publish<T extends QueryBase>(query: T): void;
}

// @public (undocumented)
export abstract class DomainException extends Error {
    protected constructor(message: string, id?: Id | undefined);
    // (undocumented)
    id?: Id | undefined;
}

// @public
const Event_2: (name?: string) => ClassDecorator;
export { Event_2 as Event }

// @public (undocumented)
export const EVENT_HANDLER_METADATA = "EVENT_HANDLER_METADATA";

// @public (undocumented)
export const EVENT_METADATA = "EVENT_METADATA";

// @public (undocumented)
export const EVENT_PUBLISHER_METADATA = "EVENT_PUBLISHER_METADATA";

// @public (undocumented)
export const EVENT_SERIALIZER_METADATA = "EVENT_SERIALIZER_METADATA";

// @public (undocumented)
export const EVENT_SOURCING_OPTIONS = "EventSourcingModuleOptions";

// @public (undocumented)
export const EVENT_SUBSCRIBER_METADATA = "EVENT_SUBSCRIBER_METADATA";

// @public (undocumented)
export class EventCollection {
    // (undocumented)
    static get(pool?: string): IEventCollection;
}

// @public (undocumented)
export class EventEnvelope<E extends IEvent = IEvent> {
    // (undocumented)
    static create<E extends IEvent = IEvent>(event: string, payload: IEventPayload<E>, metadata: Omit<EventEnvelopeMetadata, 'eventId' | 'occurredOn'> & {
        eventId?: EventId;
    }): EventEnvelope<E>;
    // (undocumented)
    readonly event: string;
    // (undocumented)
    static from<E extends IEvent = IEvent>(event: string, payload: IEventPayload<E>, metadata: EventEnvelopeMetadata): EventEnvelope<E>;
    // (undocumented)
    readonly metadata: EventEnvelopeMetadata;
    // (undocumented)
    readonly payload: IEventPayload<E>;
}

// @public
export interface EventEnvelopeMetadata {
    aggregateId: string;
    causationId?: string;
    correlationId?: string;
    eventId: EventId;
    occurredOn: Date;
    version: number;
}

// @public
export function eventFilter<TInput extends EventEnvelope, TOutput extends EventEnvelope>(...types: Type<IEvent>[]): (source: Observable<TInput>) => Observable<TOutput>;

// @public
export const EventHandler: (event: Type<IEvent>) => PropertyDecorator;

// @public (undocumented)
export interface EventHandlerMetadata {
    // (undocumented)
    method?: string;
}

// @public
export class EventId extends ULID {
    // (undocumented)
    static factory(): (dateSeed?: Date) => EventId;
    // (undocumented)
    static from(id: string): ULID;
    // (undocumented)
    static generate(dateSeed?: Date): ULID;
}

// @public (undocumented)
export class EventMap {
    // Warning: (ae-forgotten-export) The symbol "IEventName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    deserializeEvent<E extends IEvent>(eventName: IEventName, payload: IEventPayload<E>): IEventInstance<E>;
    // (undocumented)
    getConstructor<E extends IEvent>(target: IEventInstance<E> | IEventName): IEventConstructor<E>;
    // (undocumented)
    getName<E extends IEvent>(target: IEventConstructor<E> | IEventInstance<E>): IEventName;
    // (undocumented)
    has<E extends IEvent>(target: IEventMapTarget<E>): boolean;
    // Warning: (ae-forgotten-export) The symbol "IEventConstructor" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    register<E extends IEvent>(cls: IEventConstructor<E>, serializer?: IEventSerializer): void;
    // (undocumented)
    registerSerializers(events?: Type<IEvent>[], serializers?: InstanceWrapper<IEventSerializer>[]): void;
    // Warning: (ae-forgotten-export) The symbol "IEventInstance" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    serializeEvent<E extends IEvent>(event: IEventInstance<E>): IEventPayload<E>;
}

// @public (undocumented)
export interface EventMetadata {
    // (undocumented)
    id: string;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export class EventNotFoundException extends Error {
    constructor(streamId: string, version: number);
}

// @public
export const EventPublisher: () => ClassDecorator;

// @public (undocumented)
export interface EventPublisherMetadata {
    // (undocumented)
    id: string;
}

// @public
export const EventSerializer: (event: IEvent) => ClassDecorator;

// @public (undocumented)
export interface EventSerializerMetadata {
    // (undocumented)
    event: Type<IEvent>;
}

// @public (undocumented)
export type EventSerializerType = Type<IEventSerializer<IEvent>>;

// @public (undocumented)
export class EventSourcingModule {
    static forFeature(options?: {
        events: Type<IEvent>[];
    }): DynamicModule;
    // Warning: (ae-forgotten-export) The symbol "InMemoryEventStoreConfig" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "InMemorySnapshotStoreConfig" needs to be exported by the entry point index.d.ts
    static forRoot<TEventStoreConfig extends EventStoreConfig = InMemoryEventStoreConfig, TSnapshotStoreConfig extends SnapshotStoreConfig = InMemorySnapshotStoreConfig>(options: EventSourcingModuleOptions<TEventStoreConfig, TSnapshotStoreConfig>): DynamicModule;
    static forRootAsync<TEventStoreConfig extends EventStoreConfig = InMemoryEventStoreConfig, TSnapshotStoreConfig extends SnapshotStoreConfig = InMemorySnapshotStoreConfig>(options: EventSourcingModuleAsyncOptions<TEventStoreConfig, TSnapshotStoreConfig>): DynamicModule;
}

// @public (undocumented)
export interface EventSourcingModuleAsyncOptions<TEventStoreConfig extends EventStoreConfig = InMemoryEventStoreConfig, TSnapshotStoreConfig extends SnapshotStoreConfig = InMemorySnapshotStoreConfig, TOptions extends EventSourcingModuleOptions<TEventStoreConfig, TSnapshotStoreConfig> = EventSourcingModuleOptions<TEventStoreConfig, TSnapshotStoreConfig>, TFactory extends EventSourcingOptionsFactory<TEventStoreConfig, TSnapshotStoreConfig, TOptions> = EventSourcingOptionsFactory<TEventStoreConfig, TSnapshotStoreConfig, TOptions>> extends Pick<ModuleMetadata, 'imports'> {
    // (undocumented)
    inject?: any[];
    // (undocumented)
    useClass?: Type<TFactory>;
    // (undocumented)
    useExisting?: Type<TFactory>;
    // (undocumented)
    useFactory?: (...args: any[]) => Promise<TOptions> | TOptions;
    // (undocumented)
    useValue?: TOptions;
}

// @public (undocumented)
export interface EventSourcingModuleOptions<TEventStoreConfig extends EventStoreConfig = InMemoryEventStoreConfig, TSnapshotStoreConfig extends SnapshotStoreConfig = InMemorySnapshotStoreConfig> {
    events?: Type<IEvent>[];
    // (undocumented)
    eventStore?: TEventStoreConfig;
    // (undocumented)
    snapshotStore?: TSnapshotStoreConfig;
}

// @public (undocumented)
export interface EventSourcingOptionsFactory<TEventStoreConfig extends EventStoreConfig = InMemoryEventStoreConfig, TSnapshotStoreConfig extends SnapshotStoreConfig = InMemorySnapshotStoreConfig, TOptions extends EventSourcingModuleOptions<TEventStoreConfig, TSnapshotStoreConfig> = EventSourcingModuleOptions<TEventStoreConfig, TSnapshotStoreConfig>> {
    // (undocumented)
    createEventSourcingOptions: () => Promise<TOptions> | TOptions;
}

// @public (undocumented)
export abstract class EventStore<TOptions = Omit<EventSourcingModuleOptions['eventStore'], 'driver'>> implements EventStoreDriver {
    constructor(eventMap: EventMap, options: TOptions);
    abstract appendEvents(eventStream: EventStream, version: number, events: IEvent[], pool?: IEventPool): Promise<EventEnvelope[]>;
    abstract connect(): void | Promise<void>;
    abstract disconnect(): void | Promise<void>;
    abstract ensureCollection(pool?: IEventPool): IEventCollection | Promise<IEventCollection>;
    // (undocumented)
    protected readonly eventMap: EventMap;
    abstract getAllEnvelopes(filter: IAllEventsFilter): AsyncGenerator<EventEnvelope[]>;
    abstract getEnvelope?(eventStream: EventStream, version: number, pool?: IEventPool): EventEnvelope | Promise<EventEnvelope>;
    abstract getEnvelopes?(eventStream: EventStream, filter?: IEventFilter): AsyncGenerator<EventEnvelope[]>;
    abstract getEvent(eventStream: EventStream, version: number, pool?: IEventPool): IEvent | Promise<IEvent>;
    abstract getEvents(eventStream: EventStream, filter?: IEventFilter): AsyncGenerator<IEvent[]>;
    // (undocumented)
    protected getYearMonthRange(sinceDate: {
        year: number;
        month: number;
    }, untilDate?: {
        year: number;
        month: number;
    }): string[];
    abstract listCollections(filter?: IEventCollectionFilter): AsyncGenerator<IEventCollection[]>;
    // (undocumented)
    protected readonly logger: Logger;
    // (undocumented)
    protected readonly options: TOptions;
    set publish(fn: (envelope: EventEnvelope<IEvent>) => any);
    // (undocumented)
    protected _publish: (envelope: EventEnvelope<IEvent>) => any;
}

// @public
export class EventStoreCollectionCreationException extends Error {
    constructor(collection: IEventCollection, input: Error);
}

// @public (undocumented)
export interface EventStoreConfig {
    // (undocumented)
    driver: Type<EventStoreDriver>;
    useDefaultPool?: boolean;
}

// @public (undocumented)
export interface EventStoreDriver {
    // (undocumented)
    connect(): void | Promise<void>;
    // (undocumented)
    disconnect(): void | Promise<void>;
    // (undocumented)
    ensureCollection(pool?: IEventPool): unknown | Promise<unknown>;
}

// @public
export class EventStorePersistenceException extends Error {
    constructor(collection: IEventCollection, input: Error);
}

// @public
export class EventStoreVersionConflictException extends Error {
    constructor(input: EventStream, eventVersion: number, latestVersion: number, error?: Error);
}

// @public (undocumented)
export class EventStream {
    // (undocumented)
    get aggregateId(): string;
    // (undocumented)
    static for<A extends AggregateRoot = AggregateRoot>(aggregate: A | Type<A>, id: Id): EventStream;
    // (undocumented)
    get streamId(): string;
}

// @public
export const EventSubscriber: (...events: IEvent[]) => ClassDecorator;

// @public (undocumented)
export interface EventSubscriberMetadata {
    // (undocumented)
    events: Type<IEvent>[];
}

// @public (undocumented)
export const getAggregateMetadata: (cls: Type<AggregateRoot>) => AggregateMetadata;

// @public (undocumented)
export const getCommandHandlerMetadata: (commandHandler: Type<ICommandHandler>) => CommandHandlerMetadata;

// @public (undocumented)
export const getCommandMetadata: (command: Type<ICommand>) => CommandMetadata;

// @public (undocumented)
export const getEventHandlerMetadata: (aggregate: AggregateRoot, eventClass: Type<IEvent>) => EventHandlerMetadata;

// @public (undocumented)
export const getEventMetadata: (event: Type<IEvent>) => EventMetadata;

// @public (undocumented)
export const getEventPublisherMetadata: (eventPublisher: Type<IEventPublisher>) => EventPublisherMetadata;

// @public (undocumented)
export const getEventSerializerMetadata: (eventSerializer: Type<IEventSerializer>) => EventSerializerMetadata;

// @public (undocumented)
export const getEventSubscriberMetadata: (eventSubscriber: Type<IEventSubscriber>) => EventSubscriberMetadata;

// @public (undocumented)
export const getQueryHandlerMetadata: (queryHandler: Type<IQueryHandler>) => QueryHandlerMetadata;

// @public (undocumented)
export const getQueryMetadata: (query: Type<IQuery>) => QueryMetadata;

// @public (undocumented)
export const getSnapshotMetadata: <A extends AggregateRoot>(snapshotRepository: Type<ISnapshotRepository<A>>) => SnapshotRepositoryMetadata<A>;

// @public (undocumented)
export interface IAllEventsFilter extends Pick<IEventFilter, 'pool' | 'batch'> {
    since: {
        year: number;
        month: number;
    };
    until?: {
        year: number;
        month: number;
    };
}

// @public (undocumented)
export type ICommand = any;

// @public (undocumented)
export interface ICommandBus<CommandBase extends ICommand = ICommand> {
    // (undocumented)
    execute<T extends CommandBase, R = any>(command: T): Promise<R>;
}

// @public (undocumented)
export interface ICommandHandler<TCommand extends ICommand = any, TResult = any> {
    // (undocumented)
    execute(command: TCommand): Promise<TResult>;
}

// @public (undocumented)
export interface ICommandPublisher<CommandBase extends ICommand = ICommand> {
    // (undocumented)
    publish<T extends CommandBase = CommandBase>(command: T): any;
}

// Warning: (ae-forgotten-export) The symbol "Props" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Id extends ValueObject<Props> {
    protected constructor(id: string);
    // (undocumented)
    static from(id: string): Id;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export class IdAlreadyRegisteredException extends Error {
    static withId(id: Id): IdAlreadyRegisteredException;
}

// @public (undocumented)
export class IdNotFoundException extends Error {
    static withId(id: Id): IdNotFoundException;
}

// @public (undocumented)
export type IEvent = {};

// @public (undocumented)
export interface IEventBus {
    // (undocumented)
    publish(envelope: EventEnvelope): void | Promise<void>;
}

// @public (undocumented)
export type IEventCollection = 'events' | `${IEventPool}-events`;

// @public (undocumented)
export interface IEventCollectionFilter {
    batch?: number;
}

// @public (undocumented)
export interface IEventFilter {
    batch?: number;
    direction?: StreamReadingDirection;
    fromVersion?: number;
    limit?: number;
    pool?: IEventPool;
}

// @public (undocumented)
export type IEventHandlerMethod<E extends IEvent> = (event: E) => void;

// @public (undocumented)
export type IEventMapTarget<E extends IEvent = IEvent> = IEventName | IEventConstructor<E> | IEventInstance<E>;

// @public (undocumented)
export type IEventPayload<E extends IEvent> = Record<keyof E, any>;

// @public (undocumented)
export type IEventPool = string;

// @public (undocumented)
export interface IEventPublisher {
    // (undocumented)
    publish(envelope: EventEnvelope, ...params: any[]): any;
}

// @public (undocumented)
export interface IEventSerializer<E extends IEvent = IEvent> {
    // (undocumented)
    deserialize(payload: IEventPayload<E>): E;
    // (undocumented)
    serialize(event: E): IEventPayload<E>;
}

// @public (undocumented)
export interface IEventSubscriber {
    // (undocumented)
    handle(envelope: EventEnvelope): any;
}

// @public (undocumented)
export interface ILatestSnapshotFilter extends Pick<ISnapshotFilter, 'batch' | 'limit' | 'pool'> {
    // (undocumented)
    aggregateId?: string;
}

// @public
export const InjectEventSourcingOptions: () => PropertyDecorator & ParameterDecorator;

// @public (undocumented)
export class InvalidAggregateStreamNameException extends Error {
    // (undocumented)
    static becauseExceedsMaxLength(target: string, maxLength: number): InvalidAggregateStreamNameException;
}

// @public (undocumented)
export class InvalidCommandHandlerException extends Error {
    constructor(commandHandler: ICommandHandler);
}

// @public (undocumented)
export class InvalidEventStreamNameException extends Error {
    // (undocumented)
    static becauseExceedsMaxLength(target: string, maxLength: number): InvalidEventStreamNameException;
}

// @public (undocumented)
export class InvalidIdException extends DomainException {
    static because(cause: string): DomainException;
    static becauseEmpty(): InvalidIdException;
    static becauseInvalid(uuid: string): InvalidIdException;
}

// @public (undocumented)
export class InvalidQueryHandlerException extends Error {
    constructor(queryHandler: IQueryHandler);
}

// @public (undocumented)
export type IQuery = any;

// @public (undocumented)
export interface IQueryBus<QueryBase extends IQuery = IQuery> {
    // (undocumented)
    execute<T extends QueryBase = QueryBase, TRes = any>(query: T): Promise<TRes>;
}

// @public (undocumented)
export interface IQueryHandler<T extends IQuery = any, TRes = any> {
    // (undocumented)
    execute(query: T): Promise<TRes>;
}

// @public (undocumented)
export interface IQueryPublisher<QueryBase extends IQuery = IQuery> {
    // (undocumented)
    publish<T extends QueryBase = QueryBase>(query: T): any;
}

// @public (undocumented)
export type IQueryResult = unknown;

// Warning: (ae-forgotten-export) The symbol "AggregatePropertyNames" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ISnapshot<TAggregate extends AggregateRoot, TDerivedAggregate = Omit<TAggregate, keyof AggregateRoot>> = {
    [Key in AggregatePropertyNames<TDerivedAggregate>]: TDerivedAggregate[Key] extends Function ? never : any;
};

// @public (undocumented)
export type ISnapshotCollection = 'snapshots' | `${ISnapshotPool}-snapshots`;

// @public (undocumented)
export interface ISnapshotCollectionFilter {
    batch?: number;
}

// @public (undocumented)
export interface ISnapshotFilter {
    batch?: number;
    direction?: StreamReadingDirection;
    fromVersion?: number;
    limit?: number;
    pool?: ISnapshotPool;
}

// @public (undocumented)
export type ISnapshotPool = string;

// @public (undocumented)
export interface ISnapshotRepository<A extends AggregateRoot> {
    // (undocumented)
    deserialize(payload: ISnapshot<A>): A;
    // (undocumented)
    serialize(aggregate: A): ISnapshot<A>;
}

// @public (undocumented)
export class MissingAggregateMetadataException extends Error {
    constructor(aggregate: {
        name: string;
    });
}

// @public (undocumented)
export class MissingCommandHandlerMetadataException extends Error {
    constructor(commandHandler: {
        name: string;
    });
}

// @public (undocumented)
export class MissingCommandMetadataException extends Error {
    constructor(command: {
        name: string;
    });
}

// @public (undocumented)
export class MissingEventHandlerException extends Error {
    constructor(aggregate: Type<AggregateRoot>, event: Type<IEvent>);
}

// @public (undocumented)
export class MissingEventMetadataException extends Error {
    constructor(event: {
        name: string;
    });
}

// @public (undocumented)
export class MissingEventPublisherMetadataException extends Error {
    constructor(eventPublisher: {
        name: string;
    });
}

// @public (undocumented)
export class MissingEventSerializerMetadataException extends Error {
    constructor(eventSerializer: {
        name: string;
    });
}

// @public (undocumented)
export class MissingEventSubscriberMetadataException extends Error {
    constructor(eventSubscriber: {
        name: string;
    });
}

// @public (undocumented)
export class MissingQueryHandlerMetadataException extends Error {
    constructor(queryHandler: {
        name: string;
    });
}

// @public (undocumented)
export class MissingQueryMetadataException extends Error {
    constructor(query: {
        name: string;
    });
}

// @public (undocumented)
export class MissingSnapshotMetadataException extends Error {
    constructor(handler: {
        name: string;
    });
}

// @public (undocumented)
export class ObservableBus<T> extends Observable<T> {
    constructor();
    // (undocumented)
    get subject$(): Subject<T>;
    // (undocumented)
    protected _subject$: Subject<T>;
}

// @public (undocumented)
export const QUERY_HANDLER_METADATA = "QUERY_HANDLER_METADATA";

// @public (undocumented)
export const QUERY_METADATA = "QUERY_METADATA";

// @public (undocumented)
export class QueryBus<QueryBase extends IQuery = IQuery> extends ObservableBus<QueryBase> implements IQueryBus<QueryBase> {
    // (undocumented)
    bind<T extends QueryBase>(handler: IQueryHandler<T>, id: string): void;
    // (undocumented)
    execute<T extends QueryBase, R = any>(query: T): Promise<R>;
    // (undocumented)
    get publisher(): IQueryPublisher<QueryBase>;
    set publisher(_publisher: IQueryPublisher<QueryBase>);
    // (undocumented)
    register(handlers?: InstanceWrapper<IQueryHandler>[]): void;
    // (undocumented)
    protected registerHandler(handler: InstanceWrapper<IQueryHandler>): void;
}

// @public
export const QueryHandler: (query: IQuery) => ClassDecorator;

// @public (undocumented)
export interface QueryHandlerMetadata {
    // (undocumented)
    query: Type<IQuery>;
}

// @public (undocumented)
export class QueryHandlerNotFoundException extends Error {
    constructor(query: {
        name: string;
    });
}

// @public (undocumented)
export interface QueryMetadata {
    // (undocumented)
    id: string;
}

// @public
export const Snapshot: <A extends AggregateRoot = AggregateRoot>(aggregate: Type<A>, options?: Omit<SnapshotRepositoryMetadata<A>, "aggregate">) => ClassDecorator;

// @public (undocumented)
export const SNAPSHOT_METADATA = "SNAPSHOT_METADATA";

// @public (undocumented)
export class SnapshotCollection {
    // (undocumented)
    static get(pool?: string): ISnapshotCollection;
}

// @public (undocumented)
export class SnapshotEnvelope<A extends AggregateRoot = AggregateRoot> {
    // (undocumented)
    static create<A extends AggregateRoot>(payload: ISnapshot<A>, metadata: Omit<SnapshotEnvelopeMetadata, 'snapshotId' | 'registeredOn'> & {
        snapshotId?: string;
    }): SnapshotEnvelope<A>;
    // (undocumented)
    static from<A extends AggregateRoot>(payload: ISnapshot<A>, metadata: SnapshotEnvelopeMetadata): SnapshotEnvelope<A>;
    // (undocumented)
    readonly metadata: SnapshotEnvelopeMetadata;
    // (undocumented)
    readonly payload: ISnapshot<A>;
}

// @public
export interface SnapshotEnvelopeMetadata {
    aggregateId: string;
    registeredOn: Date;
    snapshotId: string;
    version: number;
}

// @public (undocumented)
export class SnapshotNotFoundException extends Error {
    constructor(stream: string, version: number);
}

// @public (undocumented)
export abstract class SnapshotRepository<A extends AggregateRoot = AggregateRoot> implements ISnapshotRepository<A> {
    constructor(snapshotStore: SnapshotStore);
    // (undocumented)
    abstract deserialize(payload: ISnapshot<A>): A;
    // (undocumented)
    load(id: Id, pool?: ISnapshotPool): Promise<A>;
    // (undocumented)
    loadAll(filter?: {
        aggregateId?: Id;
        limit?: number;
        pool?: string;
    }): AsyncGenerator<SnapshotEnvelope<A>[]>;
    // (undocumented)
    loadMany(ids: Id[], pool?: ISnapshotPool): Promise<A[]>;
    // (undocumented)
    save(id: Id, aggregate: A, pool?: ISnapshotPool): Promise<void>;
    // (undocumented)
    abstract serialize(aggregate: A): ISnapshot<A>;
    // (undocumented)
    readonly snapshotStore: SnapshotStore;
}

// @public
export interface SnapshotRepositoryMetadata<A extends AggregateRoot> {
    aggregate: Type<A>;
    interval?: number;
    name: string;
}

// @public (undocumented)
export abstract class SnapshotStore<TOptions = Omit<EventSourcingModuleOptions['snapshotStore'], 'driver'>> implements SnapshotStoreDriver {
    constructor(options: TOptions);
    abstract appendSnapshot<A extends AggregateRoot>(snapshotStream: SnapshotStream, version: number, snapshot: ISnapshot<A>, pool?: ISnapshotPool): SnapshotEnvelope<A> | Promise<SnapshotEnvelope<A>>;
    abstract connect(): void | Promise<void>;
    abstract disconnect(): void | Promise<void>;
    abstract ensureCollection(pool?: ISnapshotPool): ISnapshotCollection | Promise<ISnapshotCollection>;
    abstract getEnvelope?<A extends AggregateRoot>(snapshotStream: SnapshotStream, version: number, pool?: ISnapshotPool): SnapshotEnvelope<A> | Promise<SnapshotEnvelope<A>>;
    abstract getEnvelopes?<A extends AggregateRoot>(snapshotStream: SnapshotStream, filter?: ISnapshotFilter): AsyncGenerator<SnapshotEnvelope<A>[]>;
    abstract getLastEnvelope<A extends AggregateRoot>(snapshotStream: SnapshotStream, pool?: ISnapshotPool): SnapshotEnvelope<A> | void | Promise<SnapshotEnvelope<A> | void>;
    abstract getLastEnvelopesForAggregate?<A extends AggregateRoot>(aggregate: Type<A>, filter?: ILatestSnapshotFilter): AsyncGenerator<SnapshotEnvelope<A>[]>;
    abstract getLastSnapshot<A extends AggregateRoot>(snapshotStream: SnapshotStream, pool?: ISnapshotPool): ISnapshot<A> | void | Promise<ISnapshot<A> | void>;
    abstract getLastSnapshots<A extends AggregateRoot>(snapshotStreams: SnapshotStream[], pool?: ISnapshotPool): Map<SnapshotStream, ISnapshot<A>> | Promise<Map<SnapshotStream, ISnapshot<A>>>;
    abstract getManyLastSnapshotEnvelopes?<A extends AggregateRoot>(snapshotStreams: SnapshotStream[], pool?: ISnapshotPool): Map<SnapshotStream, SnapshotEnvelope<A>> | Promise<Map<SnapshotStream, SnapshotEnvelope<A>>>;
    abstract getSnapshot<A extends AggregateRoot>(snapshotStream: SnapshotStream, version: number, pool?: ISnapshotPool): ISnapshot<A> | Promise<ISnapshot<A>>;
    abstract getSnapshots<A extends AggregateRoot>(snapshotStream: SnapshotStream, filter?: ISnapshotFilter): AsyncGenerator<ISnapshot<A>[]>;
    abstract listCollections(filter?: ISnapshotCollectionFilter): AsyncGenerator<ISnapshotCollection[]>;
    // (undocumented)
    protected readonly logger: Logger;
    // (undocumented)
    protected readonly options: TOptions;
}

// @public
export class SnapshotStoreCollectionCreationException extends Error {
    constructor(collection: ISnapshotCollection, input: Error);
}

// @public (undocumented)
export interface SnapshotStoreConfig {
    // (undocumented)
    driver: Type<SnapshotStoreDriver>;
    useDefaultPool?: boolean;
}

// @public (undocumented)
export interface SnapshotStoreDriver {
    // (undocumented)
    connect(): void | Promise<void>;
    // (undocumented)
    disconnect(): void | Promise<void>;
    // (undocumented)
    ensureCollection(pool?: ISnapshotPool): ISnapshotCollection | Promise<ISnapshotCollection>;
}

// @public
export class SnapshotStorePersistenceException extends Error {
    constructor(collection: ISnapshotCollection, input: Error);
}

// @public
export class SnapshotStoreVersionConflictException extends Error {
    constructor(input: SnapshotStream, snapshotVersion: number, latestVersion: number, error?: Error);
}

// @public (undocumented)
export class SnapshotStream {
    // (undocumented)
    get aggregate(): string;
    // (undocumented)
    get aggregateId(): string;
    // (undocumented)
    static for<A extends AggregateRoot = AggregateRoot>(aggregate: A | Type<A>, id: Id): SnapshotStream;
    // (undocumented)
    get streamId(): string;
}

// @public (undocumented)
export enum StreamReadingDirection {
    // (undocumented)
    BACKWARD = 1,
    // (undocumented)
    FORWARD = 0
}

// @public (undocumented)
export class ULID extends Id {
    protected constructor(id: string);
    // (undocumented)
    get date(): Date;
    // (undocumented)
    static factory(): (dateSeed?: Date) => ULID;
    // (undocumented)
    static from(id: string): ULID;
    // (undocumented)
    static generate(dateSeed?: Date): ULID;
    // (undocumented)
    get time(): number;
    // (undocumented)
    get value(): string;
    // (undocumented)
    get yearMonth(): string;
}

// @public (undocumented)
export const ulidFactory: () => void;

// @public (undocumented)
export class UnregisteredEventException extends Error {
    constructor(target: IEventMapTarget);
}

// @public (undocumented)
export class UnregisteredSerializerException extends Error {
    constructor(event: string);
}

// @public (undocumented)
export class UUID extends Id {
    protected constructor(id?: string);
    // (undocumented)
    static from(id: string): UUID;
    // (undocumented)
    static generate(): UUID;
    // (undocumented)
    get value(): string;
}

// Warning: (ae-forgotten-export) The symbol "ValueObjectProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export abstract class ValueObject<T extends ValueObjectProps = ValueObjectProps> {
    protected constructor(props: T);
    // (undocumented)
    equals(other: ValueObject<T>): boolean;
    // (undocumented)
    readonly props: T;
}

// (No @packageDocumentation comment for this package)

```
